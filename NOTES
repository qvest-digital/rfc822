RFC 5322 + Errata (excerpts), RFC 5234, RFC 1034, RFC 2181, RFC 1035, RFC 5321, RFC 3986
x ; no General-address-literal

  CR             =  %x0D
  LF             =  %x0A
  CRLF           =  CR LF
  HTAB           =  %x09
  SP             =  %x20
  WSP            =  SP / HTAB
  DQUOTE         =  %x22
x DIGIT          =  %x30-39
x ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
  VCHAR          =  %x21-7E

x  quoted-pair     =   "\" (VCHAR / WSP)
x  FWS             =   [*WSP CRLF] 1*WSP	; min. 1 WSP
x  ctext           =   %d33-39 /          ; Printable US-ASCII
                       %d42-91 /          ;  characters not including
                       %d93-126           ;  "(", ")", or "\"
x  ccontent        =   ctext / quoted-pair / comment
x  comment         =   "(" *([FWS] ccontent) [FWS] ")"
x  CFWS            =   (1*([FWS] comment) [FWS]) / FWS	; min. 1 WSP or comment

Runs of FWS, comment, or CFWS that occur between lexical tokens in a
structured header field are semantically interpreted as a single
space character.

x  atext           =   ALPHA / DIGIT /    ; Printable US-ASCII
                       "!" / "#" /        ;  characters not including
                       "$" / "%" /        ;  specials.  Used for atoms.
                       "&" / "'" /
                       "*" / "+" /
                       "-" / "/" /
                       "=" / "?" /
                       "^" / "_" /
                       "`" / "{" /
                       "|" / "}" /
                       "~"
x  atom            =   [CFWS] 1*atext [CFWS]
x  dot-atom-text   =   1*atext *("." 1*atext)
x  dot-atom        =   [CFWS] dot-atom-text [CFWS]

Semantically, the optional
comments and FWS surrounding the rest of the characters are not part
of the atom; the atom is only the run of atext characters in an atom,
or the atext and "." characters in a dot-atom.

x  qtext           =   %d33 /             ; Printable US-ASCII
                       %d35-91 /          ;  characters not including
                       %d93-126           ;  "\" or the quote character
x  qcontent        =   qtext / quoted-pair
x  quoted-string   =   [CFWS]
                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE
                       [CFWS]

Semantically, neither the optional CFWS outside of the quote
characters nor the quote characters themselves are part of the
quoted-string; the quoted-string is what is contained between the two
quote characters.  As stated earlier, the "\" in any quoted-pair and
(folding CRLF)

x  from            =   "From:" mailbox-list CRLF
x  to              =   "To:" address-list CRLF

x  word            =   atom / quoted-string
x  phrase          =   1*word
   unstructured    =   *([FWS] VCHAR) *WSP

x  address         =   mailbox / group
x  mailbox         =   name-addr / addr-spec
x  name-addr       =   [display-name] angle-addr
x  angle-addr      =   [CFWS] "<" addr-spec ">" [CFWS]
x  group           =   display-name ":" [group-list] ";" [CFWS]
x  display-name    =   phrase
x  mailbox-list    =   mailbox *("," mailbox)
x  address-list    =   address *("," address)
x  group-list      =   mailbox-list / CFWS

[addr-spec] If the
string can be represented as a dot-atom (that is, it contains no
characters other than atext characters or "." surrounded by atext
characters), then the dot-atom form SHOULD be used and the quoted-
string form SHOULD NOT be used.  Comments and folding white space
SHOULD NOT be used around the "@" in the addr-spec.

x  addr-spec       =   local-part "@" domain
x  local-part      =   dot-atom / quoted-string
x  domain          =   dot-domain / domain-literal
x  dot-domain      =   dot-atom
x  domain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]
x  dtext           =   %d33-90 /          ; Printable US-ASCII
                       %d94-126           ;  characters not including
                                          ;  "[", "]", or "\"
More constraints: (perhaps by a flag on the parsed address?)

x  dot-domain      =   label *("." label) ; after stripping [CFWS] around, i.e. apply on dot-atom-text
x  label           =   (ALPHA / DIGIT) [ *(ALPHA / DIGIT / "-") (ALPHA / DIGIT) ]
   dtext	   =   IPv4address / IPv6tagged	; no IPv6 Zone Identifiers
   IPv6tagged	   =   "IPv6:" IPv6address	; case-insensitive tag

Further constraints:
• local-part up to 64 octets
x• domain up to 255 octets
x• label up to 63 octets
• addr-spec up to 254 octets (due to RFC 5321 Forward-path limit)

Examples

   From: John Doe <jdoe@machine.example>
   To: Mary Smith <mary@example.net>
   Sender: Michael Jones <mjones@machine.example>

   From: "Joe Q. Public" <john.q.public@example.com>
   To: Mary Smith <mary@x.test>, jdoe@example.org, Who? <one@y.test>
   Cc: <boss@nil.test>, "Giant; \"Big\" Box" <sysservices@example.net>
'Joe Q. Public'
'Giant; "Big" Box'

   From: Pete <pete@silly.example>
   To: A Group:Ed Jones <c@a.test>,joe@where.test,John <jdoe@one.test>;
   Cc: Undisclosed recipients:;

   From: Pete(A nice \) chap) <pete(his account)@silly.test(his host)>
   To:A Group(Some people)
        :Chris Jones <c@(Chris's host.)public.example>,
            joe@example.org,
     John <jdoe@one.test> (my dear friend); (the end of the group)
   Cc:(Empty list)(start)Hidden recipients  :(nobody(that I know))  ;

Parsing human-entered names

      Note: The "period" (or "full stop") character (".") in obs-phrase
      is not a form that was allowed in earlier versions of this or any
      other specification.  Period (nor any other character from
      specials) was not allowed in phrase because it introduced a
      parsing difficulty distinguishing between phrases and portions of
      an addr-spec (see [308]section 4.4).  It appears here because the
      period character is currently used in many messages in the
      display-name portion of addresses, especially for initials in
      names, and therefore must be interpreted properly.

(* display-name    =   phrase				*)
   phrase          =   1*word / obs-phrase		; alteration new
   obs-phrase      =   word *(word / "." / CFWS)
(* word            =   atom / quoted-string		*)

; so basically do this only if regular parsing fails
; perhaps _only_ in name-addr

; OTOH, MIME allows UAs to enter “mäh <foo@example.com>”
; we might wish to allow for that (and auto-escape)?

; we’ll ignore comments in return values in the first version
; so the release will be made in time

Path.Address {
	String label;
	boolean isGroup;
	Path.AddrSpec mailbox; // if !isGroup
	List<Path.Address> mailboxen; // if isGroup 0-n
	boolean valid; // true if mailbox/all mailboxen are valid
	String toString()
}

Path.AddrSpec {
	boolean valid;
	String localPart;
	String domain;
	String toString()
}

pMailboxList, pAddressList → Path.AddressList or null on failure

Path.AddressList {
	boolean valid; // if at least one in addresses and no invalid ones
	boolean hasGroups; // true if pAddressList
	List<Path.Address> addresses;
	List<String> flattenAddresses()
	List<String> flattenAddrSpecs()
	String toString() = ", ".join(flattenAddresses())
}

pMailboxList	→ List<pMailbox>(1-n)

pAddressList	→ List<pAddress>(1-n)
			↓
		pMailbox or pGroup

pMailbox	→ [display-name] addr-spec
		* isGroup=false, displayName:string, addrSpec:?

pGroup		→ display-name List<pMailbox>(0-n)
		* isGroup=true, displayName:string, mailboxen:?

addr-spec	→ local-part domain
		* valid:bool, address:String, localPart:String, domain:String
